REST is not only (Web) API Interface

- Fenrirアプリ部
- だいぶ前に某プロジェクトでPushを高速化した話をした
- BoltzEngineやってます

* 何を話すか

- 別に会社の宣伝に来たわけじゃないので...
- 大体はREST APIが適切だけれども、そうじゃない選択肢もあるよ

* なぜこんな話をするか

プッシュは、雑に言うとデバイストークンとメッセージをセットにして、
各プラットフォームへ送ると端末へ届くというもの。
表示テキストの他に、任意の拡張データも持たせることができる。

BoltzEngineを作る以前は、DBも含めて設計していた。
けれども、アプリごとに必要なメッセージが異なる場合が多くて
思ったより使い回しができなかった。
(DB設計もそうだし、APIインターフェイスもいけてない)

汎用的なサービス(マイクロサービス)にするにはどう設計すればいいか。

* REST

当然、最初はRESTで考えますよね。

- Representational State Transfer
- HTPメソッドで特定のリソースを操作する
- このように作るといいよ的なガイドラインとか習慣(?)

* Push API

通知を行うために最低限必要なAPI

- デバイストークンを登録する
- デバイスへメッセージを配信する

** デバイス登録API

Androidでは、デバイストークンが変わる場合があるので、
今後ずっと変わらない値を使うようにする。

POST /devices
Content-Type: application/json

{
	"token": "(トークン文字列),
	"platform": "(iOS or Android)"
}

HTTP/1.1 302 Found 
Location: https://example.com/devices/:device_id

通知を無効化する場合は、LocationのURLを使って行うようにします。

DELETE /devices/:device_id
Host: example.com

** メッセージAPI

デバイスにメッセージを配信する場合は、デバイスURLにPOSTするとしましょう。

POST /devices/:device_id
Host: example.com
Content-Type: application/json

{
	"message": "hellow, world"
}

* え

- 当時はHTTP/2とかなかったので...
- 1,000端末に通知を投げる場合、1,000回リクエストするの？

* メッセージAPI v2

POST /messages
Content-Type: application/json

[
	{"message": "hello, world", "device_id": "xxxx"},
	{"message": "hello, world", "device_id": "aaaa"},
	{"message": "hello, world", "device_id": "bbbb"}
]

または、もっと省略して

{
	"message": "hello, world",
	"device_ids": ["xxxx", "aaaa", "bbbb"]
}

* ドキュメント(時間があれば話す)

- エラーの場合(RFCxxx)
- go-swagger
- goa

* RESTじゃなくてもいいんじゃね

これがRESTと呼べるものかはわからないけれど、
そこまでHTTP APIこだわる必要はないと思った

* Goにおける他の選択肢

- net/rpc

Go標準パッケージの一部
gobというGo独自のserialization
決まった形のメソッドを用意して外部から呼び出せるようにする

	type PushService struct{}

	type SendRequest struct {
		Message string
		DeviceIDs []string
	}

	type SendResponse struct {
	}

	func (*PushService) Send(req *SendRequest, resp *SendResponse) error {
	}

- net/rpcの問題は
- 通常は、Goプログラムからしか呼び出せない。
  (もしかしたら移植されているかもしれないが...)
- Go 1.8でfreezeになった(?)

freeze=致命的な問題がなければ積極的なアップデートはしない

* 余談

- log/syslog
- net/rpc
- gin

がほぼ同時に止まって割と辛い思いをしている..

* gRPC replace net/rpc

- Googleが
- HTTP/2の上でProtocol Buffer 3を使っている
- protocとprotoc-gen-goが必要
	- nix-env -i protobuf
	- go get github.com/golang/protobuf/protoc-gen-go

まずはprotoファイルを書く。

	syntax = "proto3";
	service PushService {
		// Send はSendRequestがあらわす複数のデバイスへ通知を行う。
		rpc Send (SendRequest) returns (SendResponse);
	}
	message SendRequest {
		// 通知するメッセージ
		string message = 1;
		// デバイスIDのリスト
		repeated string deviceIds = 2;
	}
	message SendResponse {
	}

protocでGoのコードを生成する。

	protoc --go_out=plugins=grpc:. (protoファイル名)

これで*.pb.goが生成されるので、生成されたパッケージをimportして実装しましょう。

	TODO: サーバ側の実装コード

gRPCは、ある程度の言語をサポートしているので、クライアントの実装も簡単です。

	TODO: GoとPythonのコード

RESTの実装と、行なっていることは同じですが、

- protoファイルからモデルを生成できる
- protoファイルはサーバ側とクライアント側で共有できる
- ドキュメントがなくてもある程度何ができるのかわかる
- APIのデザインが、素直な表現になる
	- URLじゃなくてメソッド名になる
	- エラーの場合はerrorをreturnすればいいだけ
	- ステータスコードとかいらない

* gRPCは4つの形態がある

- 1 : 1
- 1 : N
- N : 1
- N : N

それぞれの実装はFenrir DevBlogに書いたので読んでみてください。

* GraphQL

次、話は少し変わって、最近少し注目しているGraphQLです。
TODO: GraphQLの定義を書く

昨年のアドベントカレンダーで、GitHubとGitLabのクライアントを作ったんです。
GitHubのIssueをファイルツリーとしてマウントするツールだったんですが、
GitHubとGitLabのAPIって、Issueの親コメントはIssue APIでまるっと取れる、
だけど、他のコメントはIssueComment APIに分かれていて、
Issueひとつごとにコメントを読むか、
リポジトリに含まれる全てのコメントをフラットに取得するしかできないんですね。

TODO: 図を書く

なので例えば、`grep -i rpc github.com/talks@lufia#*/*`とすると、
ファイルの裏では普通にAPIを叩いているので、
github.com/lufia/talksにあるIssueの数だけリクエストが投げられてしまう。
サーバ負荷は金で解決できるかもしれないが、少なくともクライアントコードは面倒。

GraphQLは、1回または数回のリクエストで、必要なデータを取得できます。
これはリポジトリに含まれるIssueとCommentを全て引き出すクエリ。

	{
		repository {
			owner {
				login
			}
			organization
			issues {
				title
				body
				html_url
				created_at
				updated_at
				comments {
					body
					created_at
					updated_at
				}
			}
		}
	}

これを架空のサービス、https://example.com/graphqlにPOSTすると、
クエリのキーに対応した値がJSONとして返ってきます。

	{
		"owner": {
			"login": "lufia"
		},
		"organization": null,
		"issues": [
			{
				"title": "add Plan 9 support",
				"body": "I should support Plan 9.",
				"html_url": "https://github.com/lufia/taskfs/issues/1",
				"comments": [
					{
						"body": "xxxxxx",
						"created_at": "2016-12-11T23:14:00+09:00",
						"updated_at": "2016-12-11T23:14:00+09:00"
					}
				],
				"created_at": "2016-12-11T23:13:00+09:00",
				"updated_at": "2016-12-11T23:13:00+09:00"
			},
			{
				...
			}
		]
	}

階層を維持したまま必要な値を取得できて、これはとても便利だなと思いました。

ということでGoでサービスを実装する方法ですが、
まずはimportして、ルートになるオブジェクトを決めます。

	import (
		"github.com/graphql-go/graphql"
	)
	var QueryType = graphql.NewObject(graphql.ObjectConfig{
		Name: "Query",
		Fields: graphql.Fields{
			"owner": &graphql.Field{},
			"organization": &graphql.Field{},
			"issues": graphql.Field{},
		},
	})

graphql.Fieldの詳細な実装はあとで...
で、HTTPリクエストが届いた時に、JSONを返せるようにします。

	func main() {
		schema, _ := graphql.NewSchema(graphql.SchemaConfig{
			Query: QueryType,
		})
		http.HandleFunc("/graphql", func(w http.ResponseWriter, r *http.Request) {
			q, _ := ioutil.ReadAll(r.Body)
			res := graphql.Do(graphql.Params{
				Schema: schema,
				RequestString: string(q),
			})
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)
			json.NewEncoder(w).Encode(res)
		})
		http.ListenAndServe(":8080", nil)
	}

これで、/graphqlへGraphQLのクエリをPOSTすると、
QueryTypeの定義を使って必要なだけオブジェクトを組み立てて、
結果をクライアントへ返すようになります。

後回しにしていたgraphql.Fieldは、

	"login": &graphql.Field{
		Type: graphql.NewNonNull(graphql.ID),
		Description: "ログインユーザ名",
		Resolve: func(p graphql.ResolveParams) (interface{}, error) {
			if v, ok := p.Source.(*Owner); !ok {
				return nil, nil
			}
			return v.Login, nil
		},
	}

オブジェクトの場合は、graphql.NewObjectで作っておいて、それをTypeにセットします。

	var Organization = graphql.NewObject(graphql.ObjectConfig{
		...
	})
	"organization": &graphql.Field{
		Type: Organization,
		Description: "組織",
		Resolve: func(p graphql.ResolveParams) (interface{}, error) {
			if v, ok := p.Source.(*Repository); !ok {
				return nil, nil
			}
			return v.Organization, nil
		},
	}

リストもできますし。

	"issues": &graphql.Field{
		Type: graphql.NewList(Issue),
		Resolve: func(p graphql.ResolveParams) (interface{}, error) {
			if v, ok := p.Source.(*Repository); !ok {
				return []*Issue{}, nil
			}
			return v.Issues, nil
		},
	}

クエリパラメータのようなものもできます。

	"issues": &graphql.Field{
		Type: graphql.NewList(Issue),
		Args: graphql.FieldConfigArgument{
			"limit": &graphql.ArgumentConfig{
				Description: "配列の上限",
				Type: graphql.Int,
			},
		},
		Resolve: func(p graphql.ResolveParams) (interface{}, error) {
			lim := 50
			if n, ok := p.Args["limit"].(int); ok {
				lim = n
			}
			if v, ok := p.Source.(*Repository); !ok {
				return []*Issue{}, nil
			}
			return v.Issues, nil
		},
	}

他にも、GETだけではなく、mutationといって値を変更するためのリクエストも扱えます。
興味があれば色々調べてみてください。

* FUSE(おまけ)
